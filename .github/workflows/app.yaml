name: Deploy Latency App

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

jobs:
  # ------------------------------
  # 1️⃣ Build job
  # ------------------------------
  build:
    runs-on: ubuntu-latest
    outputs:
      short_hash: ${{ steps.set_tag.outputs.short_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ------------------------------
      # 1️⃣ Set image tag
      # ------------------------------
      - name: Set image tag
        id: set_tag
        run: |
          SHORT_HASH=$(git rev-parse --short HEAD)
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT

      # ------------------------------
      # 2️⃣ Build and push Docker image (Multi-Arch)
      # ------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image (Multi-Arch)
        working-directory: ./apps
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            -t ${{ secrets.DOCKER_USERNAME }}/latency-app:${{ steps.set_tag.outputs.short_hash }} \
            -t ${{ secrets.DOCKER_USERNAME }}/latency-app:latest \
            --cache-from=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/latency-app:buildcache \
            --cache-to=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/latency-app:buildcache,mode=max \
            . --push

  # ------------------------------
  # 2️⃣ Deploy job
  # ------------------------------
  deploy:
    runs-on: ubuntu-latest
    environment: aws
    needs: build
    env:
      SHORT_HASH: ${{ needs.build.outputs.short_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ------------------------------
      # 3️⃣ Configure AWS credentials
      # ------------------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-1

      # ------------------------------
      # 4️⃣ Get EC2 instance ID dynamically
      # ------------------------------
      - name: Get EC2 instance ID by tag
        id: get_instance_id
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:server_name,Values=server-1" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Error: No running instance found with tag server_name=server-1"
            exit 1
          fi

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Found instance ID: $INSTANCE_ID"

      # ------------------------------
      # 5️⃣ Capture previous running image
      # ------------------------------
      - name: Get previous running image
        run: |
          COMMAND_ID=$(aws ssm send-command \
          --targets "Key=instanceIds,Values=$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["docker inspect --format '\''{{.Config.Image}}'\'' latency-app"]' \
          --query "Command.CommandId" \
          --output text)

          PREVIOUS_IMAGE=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query "StandardOutputContent" \
          --output text)

          echo "PREVIOUS_IMAGE=$PREVIOUS_IMAGE"
          echo "PREVIOUS_IMAGE=$PREVIOUS_IMAGE" >> $GITHUB_ENV

          # Check if empty → first deploy
          if [ -z "$PREVIOUS_IMAGE" ]; then
            echo "FIRST_DEPLOY=true"
            echo "FIRST_DEPLOY=true" >> $GITHUB_ENV
          else
            echo "FIRST_DEPLOY=false"
            echo "FIRST_DEPLOY=false" >> $GITHUB_ENV
          fi

      - name: Get private IP of server-2
        id: get_target_ip
        run: |
          TARGET_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:server_name,Values=server-2" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          echo "TARGET_IP=$TARGET_IP"
          echo "TARGET_IP=$TARGET_IP" >> $GITHUB_ENV

      # ------------------------------
      # 6️⃣ Deploy new image via SSM
      # ------------------------------
      - name: Deploy new image
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker pull '"${{ secrets.DOCKER_USERNAME }}"'/latency-app:'"$SHORT_HASH"' && docker stop latency-app || true && docker rm latency-app || true && docker run -d --name latency-app -p 5000:5000 -e TARGET_HOST='"$TARGET_IP"' '"${{ secrets.DOCKER_USERNAME }}"'/latency-app:'"$SHORT_HASH"'"]' \
            --query "Command.CommandId" \
            --output text)

          echo "Sent command. ID=$COMMAND_ID"

          while true; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" --output text)

            echo "Current status: $STATUS"
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then
              break
            fi
            sleep 2
          done

          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)

          ERROR_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardErrorContent" \
            --output text)

          echo "--- STDOUT ---"
          echo "$OUTPUT"
          echo "--- STDERR ---"
          echo "$ERROR_OUTPUT"

      # ------------------------------
      # 7️⃣ Validate deployment & rollback
      # ------------------------------
      - name: Validate deployment & rollback
        if: env.FIRST_DEPLOY == 'false'
        run: |
          # Get current image after deployment
          CURRENT_IMAGE=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker inspect --format {{.Config.Image}} latency-app"]' \
            --query "Command.CommandId" --output text)
      
          echo "Previous image: $PREVIOUS_IMAGE"
          echo "Current image:  $CURRENT_IMAGE"
      
          # Check if deployment actually happened
          if [ "$CURRENT_IMAGE" = "$PREVIOUS_IMAGE" ]; then
            echo "No new deployment happened (image unchanged)." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
      
          echo "New image deployed, validating /metrics endpoint..."
      
          # Validation loop: check /metrics endpoint for up to 60s (every 5s)
          MAX_RETRIES=12
          SUCCESS=0
          for i in $(seq 1 $MAX_RETRIES); do
            COMMAND_ID=$(aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["curl -s -o /dev/null -w %{http_code} http://localhost:5000/metrics"]' \
              --query "Command.CommandId" --output text)
            STATUS_CODE=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardOutputContent" \
              --output text)

            echo -e "Try $?/12 time"
            echo -e "status_code=$STATUS_CODE"

            if [ "$STATUS_CODE" = "200" ]; then
              SUCCESS=1
              echo "✅ /metrics is ready!"
              break
            fi
            sleep 5
          done
      
          if [ "$SUCCESS" -eq 0 ]; then
            echo "Deployment failed, rolling back to previous image..." >> $GITHUB_STEP_SUMMARY
            aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=[\"docker stop latency-app || true && docker rm latency-app || true && docker run -d --name latency-app -p 5000:5000 $PREVIOUS_IMAGE\"]"
            exit 1
          fi
      
          echo "Deployment validated successfully!" >> $GITHUB_STEP_SUMMARY

      # -----------------------------------------------
      # 7️⃣' If this is first deploy then only need to validate
      # -----------------------------------------------
      - name: First deploy & validate
        if: env.FIRST_DEPLOY == 'true'
        run: |
          echo "First deployment, no previous image to compare."

          # Run initial image
          aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"docker run -d --name latency-app -p 5000:5000 myuser/latency-app:$SHORT_HASH\"]"

          echo "Waiting for /metrics endpoint to be ready..."

          # Validation loop: check /metrics endpoint for up to 60s (every 5s)
          MAX_RETRIES=12
          SUCCESS=0
          for i in $(seq 1 $MAX_RETRIES); do
            STATUS_CODE=$(aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["curl -s -o /dev/null -w %{http_code} h_]()
