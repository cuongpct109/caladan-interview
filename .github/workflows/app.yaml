name: Deploy Latency App

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

jobs:
  # ------------------------------
  # Build job
  # ------------------------------
  build:
    runs-on: ubuntu-latest
    outputs:
      short_hash: ${{ steps.set_tag.outputs.short_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ------------------------------
      # Set image tag
      # ------------------------------
      - name: Set image tag
        id: set_tag
        run: |
          SHORT_HASH=$(git rev-parse --short HEAD)
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT

      # ------------------------------
      # Build and push Docker image (Multi-Arch)
      # ------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image (Multi-Arch)
        working-directory: ./apps
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            -t ${{ secrets.DOCKER_USERNAME }}/latency-app:${{ steps.set_tag.outputs.short_hash }} \
            -t ${{ secrets.DOCKER_USERNAME }}/latency-app:latest \
            --cache-from=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/latency-app:buildcache \
            --cache-to=type=registry,ref=${{ secrets.DOCKER_USERNAME }}/latency-app:buildcache,mode=max \
            . --push

  # ------------------------------
  # Deploy job
  # ------------------------------
  deploy:
    runs-on: ubuntu-latest
    environment: aws
    needs: build
    env:
      SHORT_HASH: ${{ needs.build.outputs.short_hash }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # ------------------------------
      # Configure AWS credentials
      # ------------------------------
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-1

      # ------------------------------
      # Get EC2 instance ID dynamically
      # ------------------------------
      - name: Get EC2 instance ID by tag
        id: get_instance_id
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:server_name,Values=server-1" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Error: No running instance found with tag server_name=server-1"
            exit 1
          fi

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Found instance ID: $INSTANCE_ID"

      # ------------------------------
      # Capture previous running image
      # ------------------------------
      - name: Get previous running image
        run: |
          # Send command to inspect the service image
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker service inspect --format '\''{{.Spec.TaskTemplate.ContainerSpec.Image}}'\'' latency-app"]' \
            --query "Command.CommandId" \
            --output text)

          # Get actual previous image
          PREVIOUS_IMAGE=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)

          echo "PREVIOUS_IMAGE=$PREVIOUS_IMAGE"
          echo "PREVIOUS_IMAGE=$PREVIOUS_IMAGE" >> $GITHUB_ENV

          # Check if empty → first deploy
          if [ -z "$PREVIOUS_IMAGE" ] || [ "$PREVIOUS_IMAGE" = "None" ]; then
            echo "FIRST_DEPLOY=true"
            echo "FIRST_DEPLOY=true" >> $GITHUB_ENV
          else
            echo "FIRST_DEPLOY=false"
            echo "FIRST_DEPLOY=false" >> $GITHUB_ENV
          fi

      - name: Get private IP of server-2
        id: get_target_ip
        run: |
          TARGET_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:server_name,Values=server-2" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PrivateIpAddress" \
            --output text)
          echo "TARGET_IP=$TARGET_IP"
          echo "TARGET_IP=$TARGET_IP" >> $GITHUB_ENV

      - name: Ensure Docker Swarm is initialized
        run: |
          # Send command to check Swarm state
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker info --format '\''{{.Swarm.LocalNodeState}}'\''"]' \
            --query "Command.CommandId" --output text)

          # Wait a short moment to ensure the command runs
          sleep 2

          # Get actual node state
          NODE_STATE=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" --output text)

          echo "Swarm state: $NODE_STATE"
      
          # If Swarm is not active, initialize it
          if [ "$NODE_STATE" != "active" ]; then
            echo "Swarm not initialized. Initializing..."
            NODE_STATE=$(aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["docker swarm init --advertise-addr $(hostname -I | awk '\''{print $1}'\'')"]')
          else
            echo "Swarm already initialized."
          fi

      - name: Deploy new image via Docker Swarm
        run: |
          # ------------------------------
          # Check if service exists
          # ------------------------------
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker service ls --filter name=latency-app -q"]' \
            --query "Command.CommandId" --output text)
      
          SERVICE_EXISTS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" --output text)
      
          echo "Service exists: $SERVICE_EXISTS"
      
          # ------------------------------
          # Create or update service
          # ------------------------------
          if [ -z "$SERVICE_EXISTS" ]; then
            echo "Service does not exist. Creating..."
            aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["docker service create --name latency-app --replicas 2 -p 5000:5000 -e TARGET_HOST='"$TARGET_IP"' '"${{ secrets.DOCKER_USERNAME }}"'/latency-app:'"$SHORT_HASH"'"]' \
              --query "Command.CommandId" --output text
          else
            echo "Service exists. Updating..."
            aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["docker service update --image '"${{ secrets.DOCKER_USERNAME }}"'/latency-app:'"$SHORT_HASH"' --replicas 2 --update-parallelism 1 --update-delay 5s latency-app"]' \
              --query "Command.CommandId" --output text
          fi
      
          # ------------------------------
          # Poll rollout status
          # ------------------------------
          echo "Waiting for service to reach desired state..."
          while true; do
            STATUS=$(aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters '{"commands":["docker service ps latency-app --filter desired-state=Running --format \"{{.Name}} {{.CurrentState}}\""]}' \
              --query "Command.CommandId" --output text)
      
            OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$STATUS" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardOutputContent" --output text)
      
            echo "$OUTPUT"
      
            if echo "$OUTPUT" | grep -v "Running" > /dev/null; then
              echo "Some replicas not ready yet"
            else
              echo "All replicas are running ✅"
              break
            fi
          done
      
      # ------------------------------
      # Validate deployment & rollback
      # ------------------------------
      - name: Validate deployment & rollback
        if: env.FIRST_DEPLOY == 'false'
        run: |
          # Get current image after deployment
          CURRENT_IMAGE=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker service inspect --format {{.Spec.TaskTemplate.ContainerSpec.Image}} latency-app"]' \
            --query "Command.CommandId" --output text)
      
          echo "Previous image: $PREVIOUS_IMAGE"
          echo "Current image:  $CURRENT_IMAGE"
      
          # Check if deployment actually happened
          if [ "$CURRENT_IMAGE" = "$PREVIOUS_IMAGE" ]; then
            echo "No new deployment happened (image unchanged)." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
      
          echo "New image deployed, validating /metrics endpoint..."

          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["curl -s -o /dev/null -w %{http_code} http://127.0.0.1:5000/metrics"]' \
            --query "Command.CommandId" --output text)

          while true; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" --output text)

            echo "Current status: $STATUS"

            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then
              break
            fi

            sleep 2
          done

          STATUS_CODE=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" --output text)

          echo "STATUS_CODE=$STATUS_CODE"

          if [ "$STATUS_CODE" = "200" ]; then
            SUCCESS=1
            echo "✅ /metrics is ready!"
            break
          fi
    
          if [ "$SUCCESS" -eq 0 ]; then
            echo "Deployment failed, rolling back to previous image..." >> $GITHUB_STEP_SUMMARY

            # Rollback service to previous image
            aws ssm send-command \
              --targets "Key=instanceIds,Values=$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=["docker service update --image '"$PREVIOUS_IMAGE"' --replicas 2 --update-parallelism 1 --update-delay 5s latency-app"]'

            exit 1
          fi

          echo "Deployment validated successfully!" >> $GITHUB_STEP_SUMMARY

      # # -----------------------------------------------
      # # First deploy & validate (Docker Swarm)
      # # -----------------------------------------------
      # - name: First deploy & validate
      #   if: env.FIRST_DEPLOY == 'true'
      #   run: |
      #     echo "First deployment, no previous image to compare."

      #     # Create the service with 2 replicas
      #     aws ssm send-command \
      #       --targets "Key=instanceIds,Values=$INSTANCE_ID" \
      #       --document-name "AWS-RunShellScript" \
      #       --parameters 'commands=["docker service create --name latency-app --replicas 2 -p 5000:5000 -e TARGET_HOST='"$TARGET_IP"' '"${{ secrets.DOCKER_USERNAME }}"'/latency-app:'"$SHORT_HASH"'"]' \
      #       --query "Command.CommandId" --output text > /dev/null

      #     echo "Waiting for /metrics endpoint to be ready..."

      #     # Validation loop: check /metrics endpoint for up to 60s (every 5s)
      #     MAX_RETRIES=12
      #     SUCCESS=0
      #     for i in $(seq 1 $MAX_RETRIES); do
      #       COMMAND_ID=$(aws ssm send-command \
      #         --targets "Key=instanceIds,Values=$INSTANCE_ID" \
      #         --document-name "AWS-RunShellScript" \
      #         --parameters 'commands=["curl -s -o /dev/null -w %{http_code} http://127.0.0.1:5000/metrics"]' \
      #         --query "Command.CommandId" --output text)
            
      #       STATUS_CODE=$(aws ssm get-command-invocation \
      #         --command-id "$COMMAND_ID" \
      #         --instance-id "$INSTANCE_ID" \
      #         --query "StandardOutputContent" \
      #         --output text)

      #       echo "Try $i/$MAX_RETRIES, status_code=$STATUS_CODE"

      #       if [ "$STATUS_CODE" = "200" ]; then
      #         SUCCESS=1
      #         echo "✅ /metrics is ready!"
      #         break
      #       fi
      #       sleep 5
      #     done

      #     if [ "$SUCCESS" -eq 0 ]; then
      #       echo "Initial deployment failed!" >> $GITHUB_STEP_SUMMARY
      #       exit 1
      #     fi

      #     echo "Initial deployment validated successfully!" >> $GITHUB_STEP_SUMMARY

